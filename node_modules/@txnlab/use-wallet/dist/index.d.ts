import { Store } from '@tanstack/store';
import algosdk from 'algosdk';
import AVMWebProviderSDK from '@agoralabs-sh/avm-web-provider';
import { InstanceWithExtensions, SDKBase } from '@magic-sdk/provider';
import { AlgorandExtension } from '@magic-ext/algorand';
import { MagicUserMetadata } from 'magic-sdk';
import { WalletConnectModalConfig } from '@walletconnect/modal';
import { SignClientTypes } from '@walletconnect/types';

declare enum LogLevel {
    DEBUG = 0,
    INFO = 1,
    WARN = 2,
    ERROR = 3
}
declare class Logger {
    private static instance;
    private level;
    private isClient;
    private constructor();
    static getInstance(): Logger;
    static setLevel(level: LogLevel): void;
    private log;
    createScopedLogger(scope: string): {
        debug: (message: string, ...args: any[]) => void;
        info: (message: string, ...args: any[]) => void;
        warn: (message: string, ...args: any[]) => void;
        error: (message: string, ...args: any[]) => void;
    };
    debug(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    error(message: string, ...args: any[]): void;
    setIsClient(isClient: boolean): void;
}
declare const logger: Logger;

interface AlgodConfig {
    token: string | algosdk.AlgodTokenHeader | algosdk.CustomTokenHeader | algosdk.BaseHTTPClient;
    baseServer: string;
    port?: string | number;
    headers?: Record<string, string>;
}
interface NetworkConfig {
    algod: AlgodConfig;
    genesisHash?: string;
    genesisId?: string;
    isTestnet?: boolean;
    caipChainId?: string;
}
declare const DEFAULT_NETWORK_CONFIG: Record<string, NetworkConfig>;
type DefaultNetworkConfig = Omit<Partial<NetworkConfig>, 'genesisHash' | 'genesisId' | 'caipChainId'>;
declare class NetworkConfigBuilder {
    private networks;
    constructor();
    mainnet(config: DefaultNetworkConfig): this;
    testnet(config: DefaultNetworkConfig): this;
    betanet(config: DefaultNetworkConfig): this;
    fnet(config: DefaultNetworkConfig): this;
    localnet(config: Partial<NetworkConfig>): this;
    addNetwork(id: string, config: NetworkConfig): this;
    build(): {
        [k: string]: NetworkConfig;
    };
}
declare enum NetworkId {
    MAINNET = "mainnet",
    TESTNET = "testnet",
    BETANET = "betanet",
    FNET = "fnet",
    LOCALNET = "localnet"
}

declare abstract class BaseWallet {
    readonly id: WalletId;
    /** Unique key for this wallet instance. Used for state storage and session isolation. */
    readonly walletKey: WalletKey;
    readonly metadata: WalletMetadata;
    protected store: Store<State>;
    protected getAlgodClient: () => algosdk.Algodv2;
    subscribe: (callback: (state: State) => void) => () => void;
    protected logger: ReturnType<typeof logger.createScopedLogger>;
    protected constructor({ id, walletKey, metadata, store, subscribe, getAlgodClient }: WalletConstructor<WalletId>);
    static defaultMetadata: WalletMetadata;
    abstract connect(args?: Record<string, any>): Promise<WalletAccount[]>;
    abstract disconnect(): Promise<void>;
    abstract resumeSession(): Promise<void>;
    setActive: () => void;
    setActiveAccount: (account: string) => void;
    abstract signTransactions<T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]): Promise<(Uint8Array | null)[]>;
    transactionSigner: (txnGroup: algosdk.Transaction[], indexesToSign: number[]) => Promise<Uint8Array[]>;
    canSignData: boolean;
    signData: (_data: string, _metadata: SignMetadata) => Promise<SignDataResponse>;
    get name(): string;
    get accounts(): WalletAccount[];
    get addresses(): string[];
    get activeAccount(): WalletAccount | null;
    get activeAddress(): string | null;
    get activeNetwork(): string;
    get isConnected(): boolean;
    get isActive(): boolean;
    get activeNetworkConfig(): NetworkConfig;
    protected onDisconnect: () => void;
    protected manageWalletConnectSession: (action: "backup" | "restore", targetWalletKey?: WalletKey) => void;
}

type CustomProvider = {
    connect(args?: Record<string, any>): Promise<WalletAccount[]>;
    disconnect?(): Promise<void>;
    resumeSession?(): Promise<WalletAccount[] | void>;
    signTransactions?<T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]): Promise<(Uint8Array | null)[]>;
    transactionSigner?(txnGroup: algosdk.Transaction[], indexesToSign: number[]): Promise<Uint8Array[]>;
    signData?(data: string, metadata: SignMetadata): Promise<SignDataResponse>;
};
interface CustomWalletOptions {
    provider: CustomProvider;
}
declare class CustomWallet extends BaseWallet {
    private provider;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.CUSTOM>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    connect: (args?: Record<string, any>) => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
    transactionSigner: (txnGroup: algosdk.Transaction[], indexesToSign: number[]) => Promise<Uint8Array[]>;
    signData: (data: string, metadata: SignMetadata) => Promise<SignDataResponse>;
}

interface DeflyWalletConnectOptions {
    bridge?: string;
    shouldShowSignTxnToast?: boolean;
    chainId?: 416001 | 416002 | 416003 | 4160;
}
declare class DeflyWallet extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.DEFLY>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    setActive: () => void;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

declare abstract class AVMProvider extends BaseWallet {
    avmWebClient: AVMWebProviderSDK.AVMWebClient | null;
    protected avmWebProviderSDK: typeof AVMWebProviderSDK | null;
    protected providerId: string;
    constructor(args: WalletConstructor<WalletId> & {
        providerId: string;
    });
    protected _initializeAVMWebProviderSDK(): Promise<typeof AVMWebProviderSDK>;
    protected _initializeAVMWebClient(): Promise<AVMWebProviderSDK.AVMWebClient>;
    protected _getGenesisHash(): Promise<string>;
    protected _mapAVMWebProviderAccountToWalletAccounts(accounts: AVMWebProviderSDK.IAccount[]): WalletAccount[];
    protected processTxns(txnGroup: algosdk.Transaction[], indexesToSign?: number[]): AVMWebProviderSDK.IARC0001Transaction[];
    protected processEncodedTxns(txnGroup: Uint8Array[], indexesToSign?: number[]): AVMWebProviderSDK.IARC0001Transaction[];
    /**
     * Abstract methods
     * These methods must be implemented by specific wallet providers
     */
    protected abstract _enable(): Promise<AVMWebProviderSDK.IEnableResult>;
    protected abstract _disable(): Promise<AVMWebProviderSDK.IDisableResult>;
    protected abstract _signTransactions(txns: AVMWebProviderSDK.IARC0001Transaction[]): Promise<AVMWebProviderSDK.ISignTransactionsResult>;
    /**
     * Common methods
     * These methods can be overridden by specific wallet providers if needed
     */
    connect(): Promise<WalletAccount[]>;
    disconnect(): Promise<void>;
    resumeSession(): Promise<void>;
    signTransactions<T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]): Promise<(Uint8Array | null)[]>;
}

declare const DEFLY_WEB_PROVIDER_ID = "95426e60-5f2e-49e9-b912-c488577be962";
declare class DeflyWebWallet extends AVMProvider {
    constructor({ id, store, subscribe, getAlgodClient, metadata }: WalletConstructor<WalletId.DEFLY_WEB>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    /**
     * Calls the "enable" method on the provider. This method will timeout after 3 minutes.
     * @returns {Promise<AVMWebProviderSDK.IEnableResult>} a promise that resolves to the result.
     * @protected
     * @throws {MethodCanceledError} if the method was cancelled by the user.
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _enable(): Promise<AVMWebProviderSDK.IEnableResult>;
    /**
     * Calls the "disable" method on the provider. This method will timeout after 0.75 seconds.
     * @returns {Promise<AVMWebProviderSDK.IDisableResult>} a promise that resolves to the result.
     * @protected
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _disable(): Promise<AVMWebProviderSDK.IDisableResult>;
    /**
     * Calls the "signTransactions" method to sign the supplied ARC-0001 transactions. This method will timeout after 3
     * minutes.
     * @returns {Promise<AVMWebProviderSDK.ISignTransactionsResult>} a promise that resolves to the result.
     * @protected
     * @throws {InvalidInputError} if computed group ID for the txns does not match the assigned group ID.
     * @throws {InvalidGroupIdError} if the unsigned txns is malformed or not conforming to ARC-0001.
     * @throws {MethodCanceledError} if the method was cancelled by the user.
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnauthorizedSignerError} if a signer in the request is not authorized by the provider.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _signTransactions(txns: AVMWebProviderSDK.IARC0001Transaction[]): Promise<AVMWebProviderSDK.ISignTransactionsResult>;
}

/** @see https://docs.exodus.com/api-reference/algorand-provider-arc-api/ */
interface EnableNetworkOpts {
    genesisID?: string;
    genesisHash?: string;
}
interface EnableAccountsOpts {
    accounts?: string[];
}
type ExodusOptions = EnableNetworkOpts & EnableAccountsOpts;
interface EnableNetworkResult {
    genesisID: string;
    genesisHash: string;
}
interface EnableAccountsResult {
    accounts: string[];
}
type EnableResult = EnableNetworkResult & EnableAccountsResult;
type SignTxnsResult = (string | null)[];
interface Exodus {
    isConnected: boolean;
    address: string | null;
    enable: (options?: ExodusOptions) => Promise<EnableResult>;
    signTxns: (transactions: WalletTransaction[]) => Promise<SignTxnsResult>;
}
type WindowExtended = {
    algorand: Exodus;
} & Window & typeof globalThis;
declare class ExodusWallet extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.EXODUS>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

declare const KIBISIS_AVM_WEB_PROVIDER_ID = "f6d1c86b-4493-42fb-b88d-a62407b4cdf6";
declare const ICON: string;
declare class KibisisWallet extends AVMProvider {
    constructor({ id, store, subscribe, getAlgodClient, metadata }: WalletConstructor<WalletId.KIBISIS>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    /**
     * Calls the "enable" method on the provider. This method will timeout after 3 minutes.
     * @returns {Promise<AVMWebProviderSDK.IEnableResult>} a promise that resolves to the result.
     * @protected
     * @throws {MethodCanceledError} if the method was cancelled by the user.
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _enable(): Promise<AVMWebProviderSDK.IEnableResult>;
    /**
     * Calls the "disable" method on the provider. This method will timeout after 0.75 seconds.
     * @returns {Promise<AVMWebProviderSDK.IDisableResult>} a promise that resolves to the result.
     * @protected
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _disable(): Promise<AVMWebProviderSDK.IDisableResult>;
    /**
     * Calls the "signTransactions" method to sign the supplied ARC-0001 transactions. This method will timeout after 3
     * minutes.
     * @returns {Promise<AVMWebProviderSDK.ISignTransactionsResult>} a promise that resolves to the result.
     * @protected
     * @throws {InvalidInputError} if computed group ID for the txns does not match the assigned group ID.
     * @throws {InvalidGroupIdError} if the unsigned txns is malformed or not conforming to ARC-0001.
     * @throws {MethodCanceledError} if the method was cancelled by the user.
     * @throws {MethodNotSupportedError} if the method is not supported for the configured network.
     * @throws {MethodTimedOutError} if the method timed out by lack of response (>= 3 minutes).
     * @throws {NetworkNotSupportedError} if the network is not supported for the configured network.
     * @throws {UnauthorizedSignerError} if a signer in the request is not authorized by the provider.
     * @throws {UnknownError} if the response result is empty.
     */
    protected _signTransactions(txns: AVMWebProviderSDK.IARC0001Transaction[]): Promise<AVMWebProviderSDK.ISignTransactionsResult>;
}

interface KmdConstructor {
    token: string | algosdk.KMDTokenHeader | algosdk.CustomTokenHeader;
    baseServer?: string;
    port?: string | number;
    headers?: Record<string, string>;
    promptForPassword: () => Promise<string>;
}
type KmdOptions = Partial<Pick<KmdConstructor, 'token' | 'promptForPassword'>> & Omit<KmdConstructor, 'token' | 'promptForPassword'> & {
    wallet?: string;
};
declare class KmdWallet extends BaseWallet {
    private client;
    private options;
    private walletName;
    private walletId;
    private password;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.KMD>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
    private fetchWalletId;
    private fetchToken;
    private releaseToken;
    private getPassword;
    private fetchAccounts;
}

interface LuteConnectOptions {
    siteName?: string;
}
declare class LuteWallet extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.LUTE>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    private getGenesisId;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
    canSignData: boolean;
    signData: (data: string, metadata: SignMetadata) => Promise<SignDataResponse>;
}

/** @see https://magic.link/docs/blockchains/other-chains/other/algorand */
interface MagicAuthOptions {
    apiKey?: string;
}
type MagicAuthClient = InstanceWithExtensions<SDKBase, {
    algorand: AlgorandExtension;
}>;
declare class MagicAuth extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    userInfo: MagicUserMetadata | null;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.MAGIC>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: (args?: Record<string, any>) => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

interface MnemonicConstructor {
    persistToStorage?: boolean;
    promptForMnemonic: () => Promise<string | null>;
}
type MnemonicOptions = Partial<Pick<MnemonicConstructor, 'promptForMnemonic'>> & Omit<MnemonicConstructor, 'promptForMnemonic'>;
declare const LOCAL_STORAGE_MNEMONIC_KEY = "@txnlab/use-wallet:v4_mnemonic";
declare class MnemonicWallet extends BaseWallet {
    private account;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.MNEMONIC>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private loadMnemonicFromStorage;
    private saveMnemonicToStorage;
    private removeMnemonicFromStorage;
    private checkMainnet;
    private initializeAccount;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

interface PeraWalletConnectOptions {
    bridge?: string;
    shouldShowSignTxnToast?: boolean;
    chainId?: 416001 | 416002 | 416003 | 4160;
    compactMode?: boolean;
}
declare class PeraWallet extends BaseWallet {
    private client;
    private options;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.PERA>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    setActive: () => void;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

interface SignClientOptions {
    projectId: string;
    relayUrl?: string;
    metadata?: SignClientTypes.Metadata;
}
type WalletConnectModalOptions = Pick<WalletConnectModalConfig, 'enableExplorer' | 'explorerRecommendedWalletIds' | 'privacyPolicyUrl' | 'termsOfServiceUrl' | 'themeMode' | 'themeVariables'>;
type WalletConnectBaseOptions = SignClientOptions & WalletConnectModalOptions;
interface WalletConnectOptions extends WalletConnectBaseOptions {
    /**
     * Optional skin to apply to this WalletConnect instance.
     * Can be either:
     * - A string ID referencing a built-in skin (e.g., 'biatec')
     * - A full skin object with id, name, and icon
     *
     * When a skin is applied, the wallet will use the skin's metadata
     * and a unique walletKey for state isolation.
     */
    skin?: WalletConnectSkinOption;
}
type SignTxnsResponse = Array<Uint8Array | number[] | string | null | undefined>;
declare class SessionError extends Error {
    constructor(message: string);
}
declare class WalletConnect extends BaseWallet {
    private client;
    private options;
    private modal;
    private modalOptions;
    private session;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.WALLETCONNECT>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    /**
     * Get metadata from the current window. This is adapted from the @walletconnect/utils
     * implementation, to avoid requiring the entire package as a dependency.
     * @see https://github.com/WalletConnect/walletconnect-utils/blob/master/browser/window-metadata/src/index.ts
     */
    private getWindowMetadata;
    private initializeClient;
    private initializeModal;
    private onSessionConnected;
    get activeChainId(): string;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

/**
 * Web3Auth Wallet Provider for Algorand
 *
 * SECURITY CONSIDERATIONS:
 * - Web3Auth exposes the raw private key for non-EVM chains like Algorand
 * - This implementation uses SecureKeyContainer to minimize key exposure
 * - Keys are never persisted to localStorage or any storage
 * - Keys are cleared from memory immediately after signing operations
 * - Session resumption requires re-authentication (keys are not cached)
 *
 * @see https://web3auth.io/docs
 */

/**
 * Parameters for custom authentication (e.g., Firebase, custom JWT)
 */
interface Web3AuthCustomAuth {
    /**
     * Custom verifier name configured in Web3Auth dashboard
     */
    verifier: string;
    /**
     * User identifier (e.g., email, Firebase UID)
     */
    verifierId: string;
    /**
     * JWT token from your authentication provider (e.g., Firebase ID token)
     */
    idToken: string;
}
/**
 * Credentials returned by getAuthCredentials callback
 */
interface Web3AuthCredentials {
    /**
     * JWT token from your authentication provider (e.g., Firebase ID token)
     */
    idToken: string;
    /**
     * User identifier (e.g., email, Firebase UID)
     */
    verifierId: string;
    /**
     * Custom verifier name (optional, uses options.verifier if not provided)
     */
    verifier?: string;
}
/**
 * Web3Auth configuration options
 */
interface Web3AuthOptions {
    /**
     * Web3Auth Client ID from the dashboard
     * @see https://dashboard.web3auth.io
     */
    clientId: string;
    /**
     * Web3Auth network (mainnet, testnet, sapphire_mainnet, sapphire_devnet, cyan, aqua)
     * @default 'sapphire_mainnet'
     */
    web3AuthNetwork?: 'mainnet' | 'testnet' | 'sapphire_mainnet' | 'sapphire_devnet' | 'cyan' | 'aqua';
    /**
     * Login provider to use (google, facebook, twitter, discord, etc.)
     * If not specified, the Web3Auth modal will be shown
     */
    loginProvider?: 'google' | 'facebook' | 'twitter' | 'discord' | 'reddit' | 'twitch' | 'apple' | 'line' | 'github' | 'kakao' | 'linkedin' | 'weibo' | 'wechat' | 'email_passwordless' | 'sms_passwordless';
    /**
     * Login hint for email_passwordless or sms_passwordless
     */
    loginHint?: string;
    /**
     * UI configuration for the Web3Auth modal
     */
    uiConfig?: {
        appName?: string;
        appUrl?: string;
        logoLight?: string;
        logoDark?: string;
        defaultLanguage?: string;
        mode?: 'light' | 'dark' | 'auto';
        theme?: Record<string, string>;
    };
    /**
     * Whether to use the popup flow instead of redirect
     * @default true
     */
    usePopup?: boolean;
    /**
     * Default verifier name for custom authentication.
     * When set, connect() can be called with just { idToken, verifierId }
     */
    verifier?: string;
    /**
     * Callback to get fresh authentication credentials when session expires.
     * Required for automatic re-authentication with Single Factor Auth (SFA).
     *
     * If not provided and the session expires, signTransactions() will throw
     * an error requiring the user to call connect() with fresh credentials.
     *
     * @example
     * ```typescript
     * getAuthCredentials: async () => {
     *   const user = firebase.auth().currentUser
     *   if (!user) throw new Error('Not logged in')
     *   const idToken = await user.getIdToken(true)
     *   return { idToken, verifierId: user.email || user.uid }
     * }
     * ```
     */
    getAuthCredentials?: () => Promise<Web3AuthCredentials>;
}
declare class Web3AuthWallet extends BaseWallet {
    private web3auth;
    private web3authSFA;
    private options;
    private userInfo;
    /**
     * SECURITY: We store only the address, NEVER the private key.
     * Keys are fetched fresh from Web3Auth and immediately cleared after use.
     */
    private _address;
    /** Track which SDK is currently in use */
    private usingSFA;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, options, metadata }: WalletConstructor<WalletId.WEB3AUTH>);
    private loadMetadata;
    private saveMetadata;
    private clearMetadata;
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    /**
     * Initialize the Web3Auth client
     */
    private initializeClient;
    /**
     * Initialize the Web3Auth Single Factor Auth client for custom JWT authentication
     */
    private initializeSFAClient;
    /**
     * SECURITY: Fetch the private key from Web3Auth and return it in a SecureKeyContainer.
     * The caller MUST call container.clear() when done.
     *
     * @returns SecureKeyContainer holding the private key
     */
    private getSecureKey;
    /**
     * Convert a hex string to Uint8Array
     */
    private hexToBytes;
    /**
     * Connect to Web3Auth
     *
     * @param args - Optional connection arguments
     * @param args.idToken - JWT token for custom authentication (e.g., Firebase ID token)
     * @param args.verifierId - User identifier for custom authentication (e.g., email, uid)
     * @param args.verifier - Custom verifier name (uses options.verifier if not provided)
     *
     * @example
     * // Standard modal connection
     * await wallet.connect()
     *
     * @example
     * // Custom authentication with Firebase
     * await wallet.connect({
     *   idToken: firebaseIdToken,
     *   verifierId: user.email,
     *   verifier: 'my-firebase-verifier'
     * })
     */
    connect: (args?: {
        idToken?: string;
        verifierId?: string;
        verifier?: string;
    }) => Promise<WalletAccount[]>;
    /**
     * Disconnect from Web3Auth
     */
    disconnect: () => Promise<void>;
    /**
     * Resume session from cached state
     *
     * LAZY AUTHENTICATION: We do NOT connect to Web3Auth here.
     * We simply restore the cached address from localStorage.
     * Web3Auth connection is deferred until signTransactions() is called.
     */
    resumeSession: () => Promise<void>;
    /**
     * Check if Web3Auth is currently connected with a valid session
     */
    private isWeb3AuthConnected;
    /**
     * Ensure Web3Auth is connected and ready for signing.
     * Re-authenticates if the session has expired.
     *
     * This is called lazily when signTransactions() is invoked,
     */
    private ensureConnected;
    /**
     * Re-authenticate using Single Factor Auth (Firebase, custom JWT)
     *
     * Requires getAuthCredentials callback to be configured in options.
     * If the callback returns credentials for a different user, this will
     * disconnect the current wallet (the user logged out and back in as someone else).
     */
    private reconnectSFA;
    /**
     * Re-authenticate using the Web3Auth modal
     *
     * Shows the Web3Auth login modal for the user to authenticate again.
     * If they log in as a different user, this will disconnect the current wallet.
     */
    private reconnectModal;
    /**
     * Verify that the current Web3Auth session matches the cached address.
     *
     * If the address doesn't match (user logged in as someone else),
     * this disconnects the wallet entirely - it's a different identity.
     */
    private verifyAddressMatch;
    /**
     * Process transactions for signing
     */
    private processTxns;
    /**
     * Process encoded transactions for signing
     */
    private processEncodedTxns;
    /**
     * Sign transactions
     *
     * LAZY AUTHENTICATION: If the Web3Auth session has expired, this will
     * automatically re-authenticate before signing.
     *
     * SECURITY: The private key is fetched fresh, used for signing,
     * and immediately cleared from memory. The key is never stored
     * between signing operations.
     */
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

/**
 * @deprecated BiatecWallet is deprecated and will be removed in v5.
 * Use WalletConnect with the 'biatec' skin instead:
 *
 * ```typescript
 * { id: WalletId.WALLETCONNECT, options: { projectId: '...', skin: 'biatec' } }
 * ```
 */
declare class BiatecWallet extends WalletConnect {
    private static deprecationWarningShown;
    constructor(args: WalletConstructor<WalletId.BIATEC>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
}

interface W3WalletProvider {
    isConnected: () => Promise<boolean>;
    account: () => Promise<WalletAccount>;
    signTxns: (transactions: WalletTransaction[]) => Promise<(string | null)[]>;
}
declare class W3Wallet extends BaseWallet {
    private client;
    protected store: Store<State>;
    constructor({ id, store, subscribe, getAlgodClient, metadata }: WalletConstructor<WalletId.W3_WALLET>);
    static defaultMetadata: {
        name: string;
        icon: string;
    };
    private initializeClient;
    connect: () => Promise<WalletAccount[]>;
    disconnect: () => Promise<void>;
    resumeSession: () => Promise<void>;
    private processTxns;
    private processEncodedTxns;
    signTransactions: <T extends algosdk.Transaction[] | Uint8Array[]>(txnGroup: T | T[], indexesToSign?: number[]) => Promise<(Uint8Array | null)[]>;
}

declare enum WalletId {
    BIATEC = "biatec",
    DEFLY = "defly",
    DEFLY_WEB = "defly-web",
    CUSTOM = "custom",
    EXODUS = "exodus",
    KIBISIS = "kibisis",
    KMD = "kmd",
    LUTE = "lute",
    MAGIC = "magic",
    MNEMONIC = "mnemonic",
    PERA = "pera",
    WALLETCONNECT = "walletconnect",
    WEB3AUTH = "web3auth",
    W3_WALLET = "w3-wallet"
}
/**
 * Metadata for a WalletConnect skin. Used to customize the appearance of
 * a WalletConnect-based wallet in the UI.
 */
interface WalletConnectSkin {
    /** Unique identifier for the skin (e.g., 'biatec', 'voiwallet') */
    id: string;
    /** Display name for the wallet */
    name: string;
    /** Wallet icon as a data URI or URL */
    icon: string;
}
/**
 * Skin option can be either:
 * - A string ID referencing a built-in skin (e.g., 'biatec')
 * - A full WalletConnectSkin object for custom skins
 */
type WalletConnectSkinOption = string | WalletConnectSkin;
/**
 * Composite key type that can be either:
 * - A standard WalletId (for backward compatibility)
 * - A composite string for skinned WalletConnect instances (e.g., 'walletconnect:biatec')
 */
type WalletKey = WalletId | `${WalletId.WALLETCONNECT}:${string}`;
type WalletMap = {
    [WalletId.BIATEC]: typeof BiatecWallet;
    [WalletId.CUSTOM]: typeof CustomWallet;
    [WalletId.DEFLY]: typeof DeflyWallet;
    [WalletId.DEFLY_WEB]: typeof DeflyWebWallet;
    [WalletId.EXODUS]: typeof ExodusWallet;
    [WalletId.KIBISIS]: typeof KibisisWallet;
    [WalletId.KMD]: typeof KmdWallet;
    [WalletId.LUTE]: typeof LuteWallet;
    [WalletId.MAGIC]: typeof MagicAuth;
    [WalletId.MNEMONIC]: typeof MnemonicWallet;
    [WalletId.PERA]: typeof PeraWallet;
    [WalletId.WALLETCONNECT]: typeof WalletConnect;
    [WalletId.WEB3AUTH]: typeof Web3AuthWallet;
    [WalletId.W3_WALLET]: typeof W3Wallet;
};
type WalletOptionsMap = {
    [WalletId.BIATEC]: WalletConnectOptions;
    [WalletId.CUSTOM]: CustomWalletOptions;
    [WalletId.DEFLY]: DeflyWalletConnectOptions;
    [WalletId.DEFLY_WEB]: Record<string, never>;
    [WalletId.EXODUS]: ExodusOptions;
    [WalletId.KIBISIS]: Record<string, never>;
    [WalletId.KMD]: KmdOptions;
    [WalletId.LUTE]: LuteConnectOptions;
    [WalletId.MAGIC]: MagicAuthOptions;
    [WalletId.MNEMONIC]: MnemonicOptions;
    [WalletId.PERA]: PeraWalletConnectOptions;
    [WalletId.WALLETCONNECT]: WalletConnectOptions;
    [WalletId.WEB3AUTH]: Web3AuthOptions;
    [WalletId.W3_WALLET]: Record<string, never>;
};
type SupportedWallet = WalletIdConfig<WalletId> | WalletId;
type WalletConfigMap = {
    [K in keyof WalletOptionsMap]: {
        options?: WalletOptionsMap[K];
        metadata?: Partial<WalletMetadata>;
    };
};
type WalletOptions<T extends keyof WalletOptionsMap> = WalletOptionsMap[T];
type WalletConfig<T extends keyof WalletConfigMap> = WalletConfigMap[T];
type WalletIdConfig<T extends keyof WalletConfigMap> = {
    [K in T]: {
        id: K;
    } & WalletConfigMap[K];
}[T];
type NonEmptyArray<T> = [T, ...T[]];
type SupportedWallets = NonEmptyArray<SupportedWallet>;
type WalletMetadata = {
    name: string;
    icon: string;
};
interface BaseWalletConstructor {
    id: WalletId;
    /** Optional wallet key override. Defaults to id. Used for skinned WalletConnect instances. */
    walletKey?: WalletKey;
    metadata: Partial<WalletMetadata> | undefined;
    getAlgodClient: () => algosdk.Algodv2;
    store: Store<State>;
    subscribe: (callback: (state: State) => void) => () => void;
}
type WalletConstructor<T extends keyof WalletOptionsMap> = BaseWalletConstructor & {
    options?: WalletOptions<T>;
    defaultMetadata?: WalletMetadata;
};
type WalletAccount = {
    name: string;
    address: string;
};
/** @see https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0001.md#interface-multisigmetadata */
interface MultisigMetadata {
    /**
     * Multisig version.
     */
    version: number;
    /**
     * Multisig threshold value. Authorization requires a subset of signatures,
     * equal to or greater than the threshold value.
     */
    threshold: number;
    /**
     * List of Algorand addresses of possible signers for this
     * multisig. Order is important.
     */
    addrs: string[];
}
/** @see https://github.com/algorandfoundation/ARCs/blob/main/ARCs/arc-0001.md#interface-wallettransaction */
interface WalletTransaction {
    /**
     * Base64 encoding of the canonical msgpack encoding of a Transaction.
     */
    txn: string;
    /**
     * Optional authorized address used to sign the transaction when the account
     * is rekeyed. Also called the signor/sgnr.
     */
    authAddr?: string;
    /**
     * Multisig metadata used to sign the transaction
     */
    msig?: MultisigMetadata;
    /**
     * Optional list of addresses that must sign the transactions
     */
    signers?: string[];
    /**
     * Optional base64 encoding of the canonical msgpack encoding of a
     * SignedTxn corresponding to txn, when signers=[]
     */
    stxn?: string;
    /**
     * Optional message explaining the reason of the transaction
     */
    message?: string;
    /**
     * Optional message explaining the reason of this group of transaction
     * Field only allowed in the first transaction of a group
     */
    groupMessage?: string;
}
/** @see https://github.com/perawallet/connect/blob/1.3.4/src/util/model/peraWalletModels.ts */
interface SignerTransaction {
    txn: algosdk.Transaction;
    /**
     * Optional authorized address used to sign the transaction when
     * the account is rekeyed. Also called the signor/sgnr.
     */
    authAddr?: string;
    /**
     * Optional list of addresses that must sign the transactions.
     * Wallet skips to sign this txn if signers is empty array.
     * If undefined, wallet tries to sign it.
     */
    signers?: string[];
    /**
     * Optional message explaining the reason of the transaction
     */
    message?: string;
}
interface JsonRpcRequest<T = any> {
    id: number;
    jsonrpc: string;
    method: string;
    params: T;
}
declare class SignTxnsError extends Error {
    code: number;
    data?: any;
    constructor(message: string, code: number, data?: any);
}
interface Siwa {
    domain: string;
    account_address: string;
    uri: string;
    version: string;
    statement?: string;
    nonce?: string;
    'issued-at'?: string;
    'expiration-time'?: string;
    'not-before'?: string;
    'request-id'?: string;
    chain_id: '283';
    resources?: string[];
    type: 'ed25519';
}
declare class SignDataError extends Error {
    code: number;
    data?: any;
    constructor(message: string, code: number, data?: any);
}
interface SignData {
    data: string;
    signer: Uint8Array;
    domain: string;
    authenticatorData: Uint8Array;
    requestId?: string;
    hdPath?: string;
    signature?: Uint8Array;
}
interface SignDataResponse extends SignData {
    signature: Uint8Array;
}
declare enum ScopeType {
    UNKNOWN = -1,
    AUTH = 1
}
interface SignMetadata {
    scope: ScopeType;
    encoding: string;
}

type WalletState = {
    accounts: WalletAccount[];
    activeAccount: WalletAccount | null;
};
type WalletStateMap = Partial<Record<WalletKey, WalletState>>;
type ManagerStatus = 'initializing' | 'ready';
interface State {
    wallets: WalletStateMap;
    activeWallet: WalletKey | null;
    activeNetwork: string;
    algodClient: algosdk.Algodv2;
    managerStatus: ManagerStatus;
    networkConfig: Record<string, NetworkConfig>;
    customNetworkConfigs: Record<string, Partial<NetworkConfig>>;
}
declare const DEFAULT_STATE: State;

interface WalletManagerOptions {
    resetNetwork?: boolean;
    debug?: boolean;
    logLevel?: LogLevel;
}
interface WalletManagerConfig {
    wallets?: SupportedWallet[];
    networks?: Record<string, NetworkConfig>;
    defaultNetwork?: string;
    options?: WalletManagerOptions;
}
declare class WalletManager {
    _clients: Map<WalletKey, BaseWallet>;
    private baseNetworkConfig;
    store: Store<State>;
    subscribe: (callback: (state: State) => void) => () => void;
    options: {
        resetNetwork: boolean;
    };
    private logger;
    constructor({ wallets, networks, defaultNetwork, options }?: WalletManagerConfig);
    private initializeLogger;
    private determineLogLevel;
    get algodClient(): algosdk.Algodv2;
    set algodClient(algodClient: algosdk.Algodv2);
    private loadPersistedState;
    private savePersistedState;
    get status(): ManagerStatus;
    get isReady(): boolean;
    /**
     * Derive the wallet key from wallet config.
     * For WalletConnect with a skin option, returns 'walletconnect:skinId'.
     * For other wallets, returns the wallet ID.
     */
    private deriveWalletKey;
    private initializeWallets;
    get wallets(): BaseWallet[];
    getWallet(walletKey: WalletKey): BaseWallet | undefined;
    resumeSessions(): Promise<void>;
    disconnect(): Promise<void>;
    private initNetworkConfig;
    private createAlgodClient;
    getAlgodClient: () => algosdk.Algodv2;
    setActiveNetwork: (networkId: NetworkId | string) => Promise<void>;
    updateAlgodConfig(networkId: string, algodConfig: Partial<AlgodConfig>): void;
    resetNetworkConfig(networkId: string): void;
    get activeNetwork(): string;
    get networkConfig(): Record<string, NetworkConfig>;
    get activeNetworkConfig(): NetworkConfig;
    get activeWallet(): BaseWallet | null;
    get activeWalletAccounts(): WalletAccount[] | null;
    get activeWalletAddresses(): string[] | null;
    get activeAccount(): WalletAccount | null;
    get activeAddress(): string | null;
    get signTransactions(): BaseWallet['signTransactions'];
    get transactionSigner(): algosdk.TransactionSigner;
}

declare class StorageAdapter {
    static getItem(key: string): string | null;
    static setItem(key: string, value: string): void;
    static removeItem(key: string): void;
}

/**
 * Secure key handling utilities for managing sensitive cryptographic material.
 *
 * These utilities provide defense-in-depth for private key handling:
 * 1. Memory zeroing - Overwrites key material before releasing references
 * 2. Scoped key access - Keys are only available within controlled callbacks
 * 3. Automatic cleanup - Keys are cleared after use via try/finally patterns
 * 4. No persistence - Keys are never stored to disk/localStorage
 */
/**
 * Securely zeros out a Uint8Array by overwriting all bytes with zeros.
 * This helps prevent key material from lingering in memory.
 *
 * Note: JavaScript doesn't guarantee immediate memory clearing due to GC,
 * but this provides defense-in-depth by:
 * 1. Overwriting the buffer contents immediately
 * 2. Reducing the window where key material is accessible
 * 3. Preventing accidental key leakage through references
 */
declare function zeroMemory(buffer: Uint8Array): void;
/**
 * Securely zeros out a string by creating a mutable copy and clearing it.
 * Returns an empty string. The original string in memory may still exist
 * due to string immutability in JS, but this clears any mutable references.
 */
declare function zeroString(str: string): string;
/**
 * A secure container for holding private key material.
 * Provides controlled access and automatic cleanup.
 */
declare class SecureKeyContainer {
    private _secretKey;
    private _isCleared;
    constructor(secretKey: Uint8Array);
    /**
     * Check if the key has been cleared
     */
    get isCleared(): boolean;
    /**
     * Execute a callback with access to the secret key.
     * The key is automatically cleared if an error occurs.
     */
    useKey<T>(callback: (secretKey: Uint8Array) => Promise<T>): Promise<T>;
    /**
     * Execute a synchronous callback with access to the secret key.
     */
    useKeySync<T>(callback: (secretKey: Uint8Array) => T): T;
    /**
     * Securely clear the key from memory.
     * This should be called when the key is no longer needed.
     */
    clear(): void;
}
/**
 * Execute a function with a temporary secret key that is automatically
 * cleared after the function completes (success or error).
 *
 * This is the preferred pattern for one-time key operations.
 */
declare function withSecureKey<T>(secretKey: Uint8Array, callback: (container: SecureKeyContainer) => Promise<T>): Promise<T>;
/**
 * Synchronous version of withSecureKey for non-async operations.
 */
declare function withSecureKeySync<T>(secretKey: Uint8Array, callback: (container: SecureKeyContainer) => T): T;

/**
 * Fallback configuration for Webpack to handle optional wallet dependencies.
 * This allows applications to build without these packages installed,
 * enabling users to include only the wallet packages they need.
 * Each package is set to 'false', which means Webpack will provide an empty module
 * if the package is not found, preventing build errors for unused wallets.
 */
declare const webpackFallback: {
    '@agoralabs-sh/avm-web-provider': boolean;
    '@blockshake/defly-connect': boolean;
    '@magic-ext/algorand': boolean;
    '@perawallet/connect': boolean;
    '@walletconnect/modal': boolean;
    '@walletconnect/sign-client': boolean;
    '@web3auth/base': boolean;
    '@web3auth/base-provider': boolean;
    '@web3auth/modal': boolean;
    '@web3auth/single-factor-auth': boolean;
    'lute-connect': boolean;
    'magic-sdk': boolean;
};

/**
 * Built-in skins that ship with the library.
 * PRs to add new WalletConnect-compatible wallets should add entries here.
 */
declare const BUILTIN_SKINS: Record<string, WalletConnectSkin>;
/**
 * Register a custom WalletConnect skin at runtime.
 * This allows developers to add their own wallet skins without PRing the library.
 *
 * @param skin - The skin definition to register
 * @throws Error if attempting to override a built-in skin
 *
 * @example
 * ```typescript
 * import { registerSkin } from '@txnlab/use-wallet'
 *
 * registerSkin({
 *   id: 'mywallet',
 *   name: 'My Custom Wallet',
 *   icon: 'data:image/svg+xml;base64,...'
 * })
 * ```
 */
declare function registerSkin(skin: WalletConnectSkin): void;
/**
 * Get a skin by its ID from either built-in or custom registries.
 *
 * @param skinId - The skin identifier
 * @returns The skin definition, or undefined if not found
 */
declare function getSkin(skinId: string): WalletConnectSkin | undefined;
/**
 * Resolve a skin option to a full WalletConnectSkin object.
 *
 * If the option is a string, looks up the skin in the registries.
 * If the option is a full skin object, registers it as a custom skin and returns it.
 *
 * @param skinOption - Either a skin ID string or a full skin definition
 * @returns The resolved skin, or undefined if not found (when string ID provided)
 */
declare function resolveSkin(skinOption: WalletConnectSkinOption): WalletConnectSkin | undefined;

export { type AlgodConfig, BUILTIN_SKINS, BaseWallet, type BaseWalletConstructor, BiatecWallet, type CustomProvider, CustomWallet, type CustomWalletOptions, DEFAULT_NETWORK_CONFIG, DEFAULT_STATE, DEFLY_WEB_PROVIDER_ID, DeflyWallet, type DeflyWalletConnectOptions, DeflyWebWallet, type EnableResult, type Exodus, type ExodusOptions, ExodusWallet, ICON, type JsonRpcRequest, KIBISIS_AVM_WEB_PROVIDER_ID, KibisisWallet, type KmdOptions, KmdWallet, LOCAL_STORAGE_MNEMONIC_KEY, LogLevel, type LuteConnectOptions, LuteWallet, MagicAuth, type MagicAuthClient, type MagicAuthOptions, type ManagerStatus, type MnemonicOptions, MnemonicWallet, type MultisigMetadata, type NetworkConfig, NetworkConfigBuilder, NetworkId, PeraWallet, type PeraWalletConnectOptions, ScopeType, SecureKeyContainer, SessionError, type SignData, SignDataError, type SignDataResponse, type SignMetadata, SignTxnsError, type SignTxnsResponse, type SignTxnsResult, type SignerTransaction, type Siwa, type State, StorageAdapter, type SupportedWallet, type SupportedWallets, W3Wallet, type W3WalletProvider, type WalletAccount, type WalletConfig, type WalletConfigMap, WalletConnect, type WalletConnectOptions, type WalletConnectSkin, type WalletConnectSkinOption, type WalletConstructor, WalletId, type WalletIdConfig, type WalletKey, WalletManager, type WalletManagerConfig, type WalletManagerOptions, type WalletMap, type WalletMetadata, type WalletOptions, type WalletOptionsMap, type WalletState, type WalletTransaction, type Web3AuthCredentials, type Web3AuthCustomAuth, type Web3AuthOptions, Web3AuthWallet, type WindowExtended, getSkin, registerSkin, resolveSkin, webpackFallback, withSecureKey, withSecureKeySync, zeroMemory, zeroString };
